#! /usr/bin/perl -w

use Term::ANSIColor;
use Getopt::Long qw(:config auto_help bundling);
use Pod::Usage;
use strict;

my (
    $inline,
    $display,
    $count,
    $filename,
    $lines,
    $preamble,
    $postamble,
    $separate,
    $help,
    $start,
    $finish,
    $textcolour,
    $pattern,
    $man,
    $separator,
    $infile,
    $matchcount,
    $linecount,   # replace by $.
    $default,
    $mathend,
    $i,
    $mathstart,
    $postmath,
    $match,
    $op,
    $premath,
    $output,
    $endmath,
    $offset,
    $backup,
    $mathpattern,
    $replace,
    $displaymathpattern,
    $extramathpattern,
    $inlinemathpattern,
    $reset,
    $after,
    $before,
    $outfile,
    $mods,
    $pre,
    $post,
    $verbose,
    $line,
    $mathline
    );

my @input;
my @math;
my @mathpatterns;
my @mathenvs;
my @extraenvs;

#
# Get commandline options
#

GetOptions (
    "inline!" => \$inline,              # Do we exec on inline maths?
    "display!" => \$display,            # Do we exec on display maths?
    "environments=s" => \@extraenvs,    # Extra environments to check
    "count!" => \$count,                # Print a count of successes
    "filename!" => \$filename,          # Print successful filenames
    "lines!" => \$lines,                # Print line numbers
    "preamble!" => \$preamble,          # Do we exec in preamble?
    "postamble!" => \$postamble,        # Do we exec in postamble?
    "replace:s" => \$replace,           # Are we doing a replace?
    "start=i" => \$start,               # Line number to start at
    "finish=i" => \$finish,             # Line number to finish at
    "colour|color:s" => \$textcolour,   # Colour in matches
    "separate!" => \$separate,          # Do we print a separator
    "context=i" => sub {my ($a,$b) = @_; $after = $before = $b;},
                                        # Lines of context to print
    "before=i" => \$before,             # Lines before a match to print
    "after=i" => \$after,               # Lines after a match to print
    "help|?" => \$help,                 # Print help and exit
    "man" => \$man,                     # Print man page and exit
    "verbose+" => \$verbose,            # Verbosity level
    "pattern=s" => \$pattern            # Specify pattern
    ) or pod2usage(2);

# Do our best to make sure that we have a pattern
@ARGV and !$pattern and ($pattern = shift @ARGV);

# Certain simple conditions mean that we cannot continue
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;
pod2usage("$0: No pattern given.") if (!defined($pattern));
pod2usage("$0: No files given.") if ((@ARGV == 0) && (-t STDIN));

# Sort out colour.  Only works if pattern is reasonably simple.
# Doesn't currently work on patterns delimited by brackets, for
# example.

if (defined($textcolour)) {
    $textcolour = ($textcolour ? $textcolour : "red");

    eval {$textcolour = color $textcolour};
    pod2usage("$0: Couldn't figure out colour $textcolour: $@\n") if ($@);
    $reset = color 'reset';

    pod2usage("$0: Can't mix colour and replace\n") if ($pattern =~ /^\s*s/);

    $pattern =~ s/^\s*m?(.)/s$1(/;
    $pre = $1;
    $pattern =~ s/(.)([egimosx]*)\s*$/)$1/;
    $post = $1;
    $mods = $2;
    if ($pre ne $post) {
	$pattern .= $pre;
    }
    $pattern .= $textcolour . "\$1" . $reset . $post . $mods;
}

# Sanity check!
$_ = "junk";
eval $pattern;
pod2usage("Pattern doesn't compute: " . $pattern . "\n$@\n") if $@;

&errmsg(2,"Using pattern: $pattern");

# Assemble the pattern to match against to decide whether or not we
# are in mathematics.

# Extra environments can be specified using multiple --environments
# options or as comma-separated lists after one such

@extraenvs and (@extraenvs = split(/,/, join(',', @extraenvs)));

@mathenvs = ("math", "displaymath","equation", "eqnarray", "align", "gather", "multline", "flalign", "alignat");

$displaymathpattern = '\\\\begin{(' . join("\\*?|", @mathenvs) . "\\*?" . ')}|\\\\\\[';
$inlinemathpattern = '\\\\\(';
$extramathpattern = '\\\\begin{(' . join("\\*?|", @extraenvs) . "\\*?" . ')}|\\\\\\[';

$inline and push @mathpatterns, $inlinemathpattern;
$display and push @mathpatterns, $displaymathpattern;
@extraenvs and push @mathpatterns, $extramathpattern;

$mathpattern = join ("|", @mathpatterns);

# If we're not to search past \end{document} we need to know about
# that.

if ($postamble) {
    $mathpattern .= '|\\\\end\{document\}';
}

pod2usage("$0: No mathematical delimiters specified.\n") unless $mathpattern;

# Set up the output routine.  Return an anonymous subroutine which
# decides how to process the output.

($outsub, $finalout) = &outinit(
    $replace,
    $count,
    $filename,
    $lines,
    $after,
    $before,
    $separate
    );

$presub = &preinit(
    $preamble,
    $start
    );

$insub = &ininit(
    $replace
    );

unshift(@ARGV, "-") unless @ARGV;

 FILE: foreach $infile (@ARGV) {

     &errmsg(2,"Checking file $infile");

     unless (($inhandle,$outhandle) = &$insub($infile)) {
	 &errmsg(1, "Couldn't set up input for $infile");
	 next FILE;
     }

     select $outhandle;

     unless (($line, $offset) = &$presub(\$inhandle)) {
	 &errmesg(1, "No valid input in $infile");
	 next FILE;
     }
     
     # Start with some pure, pristine input; possibly with an offset
     # value in $offset.

   PROCESS: while () {

       if ($line =~ /^[^%]{$offset}[^%]*?($mathpattern)/) {

	   # It's possible that this match was against an
	   # \end{document} so we first rule out that possibility.  We
	   # don't need to condition this on '$postamble' since we
	   # could only have matched this if '$postamble' was already
	   # set.

	   if ($1 eq '\end{document}') {
	       last PROCESS;
	   }

	   # Otherwise, we matched the start of a math environment
	   # after the offset (and before any comments); record where
	   # we started and figure out how this environment should
	   # end.

	   $mathline = $.;
	   $mathstart = $+[0];

	   $endmath = &endmath($1);

	   # Start forming our array of lines to check
	   @lines = ($line);

	   # Do we have an $endmath on this line?

	   if ($lines[0] =~ /^[^%]{$mathstart}[^%]*?($endmath)/) {

	       # Record, for posterity, the point in the string where
	       # this environment ended.  This isn't quite the offset
	       # that we'll need as a replace might do something a bit
	       # funny; so we record the distance to the /end/ of the
	       # line.
		 
	       $mathend = length($lines[0]) - $-[1];

	   } else {

	       # No we don't so let's slurp in more input until we get
	       # a match on the end of this particular math
	       # environment.  Record the end point as before.

	       do {
		   eof($inhandle) and do {
		       &errmsg(1,"Input ended while waiting for $endmath");
		       next FILE;
		   };

		   push @lines, <$inhandle>;

		   # We might have gotten to the end of where we're
		   # supposed to get to
		     
	       } until (($lines[$#lines] =~ /^[^%]*$endmath/) or (defined($finish) and ($. > $finish)));

	       # If we got a match, it will be before a comment
	       # character so recording the point at which the
	       # $endmath started is simple.

	       if ($lines[$#lines] =~ /^[^%]*$endmath/) {
		   $lines[$#lines] =~ /$endmath/;
		   $mathend = length($lines[$#lines]) - $-[0];
	       } else {
		   
		   # If we didn't get a match but we have still
		   # reached this point then we have reached the end
		   # of our input.  We still want to process that
		   # which we have, though.

		   $mathend = 0;
	       }
	   }

	   # We now have a chunk of maths, we know where it started
	   # and where it ended.  Extract the bits before and after
	   # the maths.

	   $premath = substr($lines[0],0,$mathstart);
	   $postmath = substr($lines[$#lines],-$mathend);

	   # Now set $_ to the mathematical bit in the middle.  Handle
	   # two different cases depending on how many lines of input
	   # we have.

	   if ($#lines == 0) {
	       $_ = substr($lines[0],$mathstart,-$mathend);
	   } else {
	       $_ = substr($lines[0],$mathstart);
	       for (my $i = 1; $i < $#lines; $i++) {
		   $_ .= $lines[$i];
	       }
	       $_ .= substr($lines[$#lines],0,-$mathend)
	   }

	   # This is where we carry out the match or replacement.  Had
	   # to look at the '/usr/bin/rename' script to see how best
	   # to handle this.

	   ($match = eval $pattern) and $matchcount++;

	   # Now we decide what to do depending on whether or not we
	   # got a match.  Basic idea is that whatever happened, we
	   # process all but the last line of our current batch of
	   # input.  The last line of input gets saved for the next
	   # iteration as there may be more maths on it.

	   @lines = split('\n', $premath . $_ . $postmath);

	   $line = pop @lines;
	   $offset = length($line) - $mathend;

	   &$outsub(\@lines,$match,$mathline,$.);

       } else {

	   # No more maths, so process the current line and proceed.

	   &$outsub([$line],0,$.,$.);

	   # Get the next load of input, checking that we can, of
	   # course.

	   if (eof($inhandle)) {
	       last PROCESS;
	   }

	   $line = <$inhandle>;
	   $offset = 0;
       }

       # Do we exit here?

       if (defined($finish) and ($. > $finish)) {
	   last PROCESS;
       }
   }

     # No more lines to process, but we may still be called upon to
     # output some more of our input.  Should probably only do this if
     # fully necessary.

     while(<$inhandle>) {
	 &$outsub([$_],0,$.,$.);
     }

     &$finalout;

     close $inhandle;
     close $outhandle unless ($outhandle eq *STDOUT{IO});
}

exit;

sub errmsg {
    my ($v, $m) = @_;
    chomp($m);
    $m .= "\n";
    print STDERR $m if ($v >= $verbose);
}

sub preinit {
    my ($p, $s, $o) = @_;
    my ($q);
    $p and $s and return sub {
	my ($fh) = @_;
	return (undef, undef) if eof($fh);

      PREAMBLE: while (<$fh>) {
	  if (/^[^%]*\\begin\{document\}/) {
	      last PREAMBLE;
	  }
	  &$o($_,0);
      }
	    
	if ($. >= $s) {
	    return ($_,$+[0]);
	}
	    
	while (<$fh>) {
	    if ($. = $s) {
		return ($_,0);
	    }
	    &$o($_,0);
	}
	return (undef, undef);
    };

    $p and return sub {
	my ($fh) = @_;
	return (undef, undef) if eof($fh);

	while (<$fh>) {
	    if (/^[^%]*\\begin\{document\}/) {
		return ($_,$+[0]);
	    }
	    &$o($_,0);
	}
	return (undef, undef);
    };

    $s and return sub {
	my ($fh) = @_;
	return (undef, undef) if eof($fh);

	while (<$fh>) {
	    if ($. = $s) {
		return ($_,0);
	    }
	    &$o($_,0);
	}
	return (undef, undef);
    }
    
    return sub {
	my ($fh) = @_;
	return (undef, undef) if eof($fh);

	$_ = <$fh>;
	return ($_,0);
    }
}

sub endmath {
    my ($b) = @_;
    my $e;

    $e = "\\" . $b;
    $e =~ s/\*/\\*/;
    $e =~ s/\(/\\)/;
    $e =~ s/\[/\\]/;
    $e =~ s/begin/end/;

    # If we're supposed to stop at an '\end{document}' then let's add
    # that to the '$endmath' string to be sure that we stop when we
    # get there.

    if ($postamble) {
	$e .= '|\\end\{document\}';
    }

    return $e;
}

sub ininit {
    my ($r) = @_;

    $r and return sub {
	my ($i) = @_;
	my ($j,$p);

	my $b = $i . $r;
	if (-e $b) {
	    unlink $b or 
		return (undef,undef);
	}
    
	
	link $i, $b
	    and unlink $i
	    and open ($j, $b)
	    and open ($p, ">$i")
	    and return ($j,$p);

	return (undef,undef);
    };

    return sub {
	my ($i) = @_;
	my $j;

	open ($j, $i)
	    and return ($j, *STDOUT{IO});

	return (undef,undef)
    }
}

# Set up the ouput routines.  The input to the normal output
# subroutine consists of:
#  a reference to an array of lines
#  whether those lines matched
#  the starting line number
#  the ending line number
#
# We also set up a routine to be called at the end of each file, this
# takes no input.
#
# The following combinations are allowed
#  $replace and $separate
#  $count and $filename
#  $lines, $before, $after, $separate



sub outinit {
    my ($r,$c,$f,$l,$a,$b,$s) = @_;
    my ($o, $e);

    if ($r) {
	my ($t, $u);
	$t = ($s ? "%---%\n" : "");
	$u = 0;
	    
	$o = sub {
	    my ($l,$m,$s,$e) = @_;
	    if ($m != $u) {
		print $t;
	    }
	    for (my $i = 0; $i <= $#$l; $i++) {
		print $$l[$i];
	    }
	    $u = $m;
	};

	$e = sub {};

	return ($o, $e);
    }

    if ($c or $f) {
	my $n;
	$o = sub {
	};

	$e = sub {
	    print ($f ? "$infile: " : "") . $matchcount . "\n";
	};

	return ($o, $e);
    }

    $o = sub {
	my ($l,$m,$s,$e) = @_;
    };

    $e = sub {};

    return ($o, $e);
}
    
__END__

=head1 NAME

MathGrep.pl - grep through a LaTeX document looking only in math sections

=head1 SYNOPIS

mathgrep.pl [options] perlexpr [files]

    Parse through [files] or standard input performing <perlexpr> on
    any mathematics found.  The expression should be a bit of perl
    code which acts on $_.  Usually, <perlexpr> would be of the form
    '/regexp/' or 's/regexp/replace/'.

=head1 OPTIONS

"--[no]all"
    Sets the default behaviour of what to do with lines where
    <perlexpr> did not execute successfully.  <on> means print, <off>
    means don't print.
  default: off

"--colour|color [colour]"
    Highlight matched text in <colour>.
  default: red

"--[no]count" 
    Suppress normal output and instead print a count of the number of
    times <perlexpr> executed successfully.

"--[no]display"
    Whether to look in 'display' math environments.  Currently:
    "math", "displaymath","equation", "eqnarray", "align", "gather",
    "multline", "flalign", "alignat", and "\[".
  default: on

"--[no]filename"
    Suppress normal output and instead print the filename if
    <perlexpr> executed successfully at least once.  Can be combined
    with "--count".
  default: off

"--finish num"
    Stop examining the file at line <num>.  If the default action is
    to print non-matching lines, lines after <num> are still printed.

"--inline"
    Whether to look in 'inline' math environments.
  default: on

"--[no]lines"
    If set, lines where <perlexpr> executed successfully are printed
    prefixed by their line number.
  default: off

"--pattern perlexpr"
    Provides a way of protecting the perl expression.

"--[no]postamble"
    Determines whether to stop trying to execute the perl expression
    once the (first) \end{document} has been reached.
  default: off

"--preamble"
    Determines whether to start trying to execute the perl expression
    at the beginning of the document or when the (first)
    \begin{document} has been reached.
  default: off

"--replace [extension]"
    If set, all lines will be printed whether the perl expression
    executed successfully or not.  If the extension is given then the
    input files will be backed up and the output redirected to the
    input files (effectively replacing them).  If the extension is not
    set, the output is to the terminal.

"--reverse"
    Swaps the behaviour for matching and non-matching lines.

"--[no]separate"
    If set, lines where the perl expression executed successfully are
    separated by a separator string, currently '---\n'.
  default: on

"--start num"
    Ignore the first num lines.  If the default action is to print
    non-matching lines, lines after <num> are still printed.

"--help|?"
    Print this help and exit.

=head2 Bugs/Features:

   Doesn't look through $ or $$ environments yet
   Doesn't miss out \text{} or \intertext{} sections

=head2 To Do:

   Sort out $ and $$ environments (probably the main difficulty will be
   separating inline from display)

=cut
